import React, { createContext, useState, useEffect, useContext, useMemo, Children } from 'react';
import { getProfileAll, saveFileInContainer, getSolidDataset, getThing, getFile, getStringWithLocale, getStringNoLocale, getUrl, getInteger, getDecimal, getDatetime, getBoolean, getStringWithLocaleAll, getStringNoLocaleAll, getUrlAll, getIntegerAll, getDecimalAll, getDatetimeAll, getBooleanAll, overwriteFile as overwriteFile$1, removeUrl, setThing, getSourceUrl, saveSolidDatasetAt, addUrl, setDatetime, hasResourceInfo, setStringWithLocale, setStringNoLocale, setBoolean, setUrl, setInteger, setDecimal } from '@inrupt/solid-client';
import { login, logout, fetch, getDefaultSession, onSessionRestore, handleIncomingRedirect } from '@inrupt/solid-client-authn-browser';
import useSWR from 'swr';
import { useTable, useGlobalFilter, useSortBy } from 'react-table';

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const SessionContext = createContext({
    login,
    logout,
    fetch,
    session: getDefaultSession(),
    sessionRequestInProgress: true,
    profile: undefined,
});
/**
 * Used to provide session data to child components through context, as used by various provided components and the useSession hook.
 */
const SessionProvider = ({ sessionId, children, onError, sessionRequestInProgress: defaultSessionRequestInProgress, restorePreviousSession, skipLoadingProfile, onSessionRestore: onSessionRestore$1, }) => {
    const restoreSession = restorePreviousSession || typeof onSessionRestore$1 !== "undefined";
    const [session, setSession] = useState(getDefaultSession);
    const [profile, setProfile] = useState();
    useEffect(() => {
        if (onSessionRestore$1 !== undefined) {
            onSessionRestore(onSessionRestore$1);
        }
    }, [onSessionRestore$1]);
    const defaultInProgress = typeof defaultSessionRequestInProgress === "undefined"
        ? !session.info.isLoggedIn
        : defaultSessionRequestInProgress;
    // If loggedin is true, we're not making a session request.
    const [sessionRequestInProgress, setSessionRequestInProgress] = useState(defaultInProgress);
    let currentLocation;
    if (typeof window !== "undefined") {
        currentLocation = window.location;
    }
    useEffect(() => {
        handleIncomingRedirect({
            url: window.location.href,
            restorePreviousSession: restoreSession,
        })
            .then(async (sessionInfo) => {
            if (skipLoadingProfile === true) {
                return;
            }
            // If handleIncomingRedirect logged the session in, we know what the current
            // user's WebID is.
            if ((sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.webId) !== undefined) {
                const profiles = await getProfileAll(sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.webId, {
                    fetch: session.fetch,
                });
                setProfile(profiles);
            }
        })
            .catch((error) => {
            if (onError) {
                onError(error);
            }
            else {
                throw error;
            }
        })
            .finally(() => {
            // console.log("done");
            setSessionRequestInProgress(false);
        });
        getDefaultSession().on("logout", () => {
            // TODO force a refresh
            setSession(getDefaultSession());
        });
    }, [
        session,
        sessionId,
        onError,
        currentLocation,
        restoreSession,
        skipLoadingProfile,
    ]);
    const contextLogin = async (options) => {
        setSessionRequestInProgress(true);
        try {
            await login(options);
        }
        catch (error) {
            if (onError) {
                onError(error);
            }
            else {
                throw error;
            }
        }
        finally {
            setSessionRequestInProgress(false);
        }
    };
    const contextLogout = async () => {
        try {
            await logout();
            setProfile(undefined);
        }
        catch (error) {
            if (onError) {
                onError(error);
            }
            else {
                throw error;
            }
        }
    };
    return (React.createElement(SessionContext.Provider, { value: {
            session,
            login: contextLogin,
            logout: contextLogout,
            sessionRequestInProgress,
            setSessionRequestInProgress,
            fetch,
            profile,
        } }, children));
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
function FileUpload({ saveLocation, onError, onSave, inputProps, autosave, }) {
    const { fetch } = useContext(SessionContext);
    const handleChange = async (e) => {
        const target = e.target;
        // This is a typescript bug, as target.files should always be a FileList:
        if (!target.files) {
            return;
        }
        if (!autosave) {
            return;
        }
        try {
            const savedFile = await saveFileInContainer(saveLocation, target.files[0], {
                slug: target.files[0].name ? target.files[0].name : undefined,
                fetch,
            });
            if (onSave) {
                onSave(savedFile);
            }
        }
        catch (saveError) {
            if (onError) {
                onError(saveError);
            }
        }
    };
    return (React.createElement(React.Fragment, null,
        React.createElement("input", Object.assign({ type: "file" }, inputProps, { onChange: (e) => handleChange(e), "data-testid": "form-input" }))));
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
function useDataset(datasetIri, 
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
options) {
    const { fetch } = useContext(SessionContext);
    const { solidDataset: datasetFromContext } = useContext(DatasetContext);
    const { data, error } = useSWR(datasetIri ? [datasetIri, options, fetch] : null, () => {
        const requestOptions = Object.assign({ fetch }, options);
        // useSWR will only call this fetcher if datasetUri is defined
        return getSolidDataset(datasetIri, requestOptions);
    });
    const dataset = datasetIri ? data : datasetFromContext;
    return { dataset, error };
}

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const DatasetContext = createContext({
    solidDataset: undefined,
    setDataset: () => { },
});
/**
 * Used to provide a [Dataset](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-SolidDataset) to child components through context, as used by various provided components and the useDataset hook.
 */
const DatasetProvider = ({ children, onError, solidDataset: propDataset, datasetUrl, loading, loadingComponent: LoadingComponent, }) => {
    const { dataset, error } = useDataset(datasetUrl);
    if (error && onError) {
        onError(error);
    }
    const datasetToUse = propDataset !== null && propDataset !== void 0 ? propDataset : dataset;
    // Provide a setDataset function so that child components can update.
    const [stateDataset, setDataset] = useState(datasetToUse);
    // If the dataset is asynchronously loaded, make sure to set the new state value.
    useEffect(() => {
        setDataset(datasetToUse);
    }, [datasetToUse]);
    let loader = (LoadingComponent && (React.createElement(LoadingComponent, null))) ||
        loading || React.createElement("span", null, "Fetching data...");
    if (LoadingComponent === null) {
        loader = null;
    }
    return (React.createElement(DatasetContext.Provider, { value: { solidDataset: stateDataset, setDataset } }, stateDataset ? children : loader));
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const ThingContext = createContext({
    thing: null,
    setThing: () => { },
});
/**
 * Used to provide a Thing to child components through context, as used by various provided components and the useThing hook.
 */
const ThingProvider = ({ children, thing: propThing, thingUrl, }) => {
    const { solidDataset } = useContext(DatasetContext);
    let thing = propThing;
    if (solidDataset && thingUrl) {
        thing = getThing(solidDataset, thingUrl);
    }
    // Allow child components to update the thing
    const [stateThing, setThing] = useState(thing || null);
    // Reset the thing if the dataset changes.
    useEffect(() => {
        if (solidDataset && thingUrl) {
            setThing(getThing(solidDataset, thingUrl));
        }
        else if (propThing) {
            setThing(propThing);
        }
    }, [solidDataset, thingUrl, propThing]);
    return (React.createElement(ThingContext.Provider, { value: { thing: stateThing, setThing } }, children));
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const overwriteFile = async (src, file, input, fetch, maxSize, onSave, onError) => {
    try {
        if (maxSize !== undefined && file.size > maxSize * 1024) {
            input.setCustomValidity(`The selected file must not be larger than ${maxSize}kB`);
            input.reportValidity();
            return null;
        }
        input.setCustomValidity("");
        await overwriteFile$1(src, file, { fetch });
        if (onSave) {
            onSave();
        }
        const objectUrl = URL.createObjectURL(file);
        return objectUrl;
    }
    catch (error) {
        if (onError) {
            onError(error);
        }
        return null;
    }
};
const retrieveFile = async (src, fetch) => {
    const imageBlob = await getFile(src, { fetch });
    return imageBlob;
};
function getValueByType(type, thing, property, locale) {
    switch (type) {
        case "boolean":
            return getBoolean(thing, property);
        case "datetime":
            return getDatetime(thing, property);
        case "decimal":
            return getDecimal(thing, property);
        case "integer":
            return getInteger(thing, property);
        case "url":
            return getUrl(thing, property);
        default:
            if (locale) {
                return getStringWithLocale(thing, property, locale);
            }
            return getStringNoLocale(thing, property);
    }
}
function getValueByTypeAll(type, thing, property, locale) {
    switch (type) {
        case "boolean":
            return getBooleanAll(thing, property);
        case "datetime":
            return getDatetimeAll(thing, property);
        case "decimal":
            return getDecimalAll(thing, property);
        case "integer":
            return getIntegerAll(thing, property);
        case "url":
            return getUrlAll(thing, property);
        default:
            if (locale) {
                return getStringWithLocaleAll(thing, property, locale);
            }
            return getStringNoLocaleAll(thing, property);
    }
}
function getPropertyForThing(propertySelector, type, thing, properties, locale) {
    return (properties.find((property) => {
        return propertySelector(type, thing, property, locale);
    }) || properties[0]);
}
function useProperty(props) {
    const { dataset: propDataset, thing: propThing, properties: propProperties, property: propProperty, type, locale, } = props;
    const { solidDataset: contextDataset, setDataset = () => { } } = useContext(DatasetContext);
    const dataset = propDataset || contextDataset;
    const { thing: contextThing, setThing = () => { } } = useContext(ThingContext);
    const thing = propThing || contextThing || undefined;
    let error;
    if (!thing) {
        error = new Error("Thing not found as property or in context");
    }
    const property = thing && propProperties
        ? getPropertyForThing(getValueByType, type, thing, propProperties, locale) || propProperties[0]
        : propProperty;
    if (!property) {
        throw new Error("No property provided");
    }
    const value = thing && property ? getValueByType(type, thing, property, locale) : null;
    return {
        dataset,
        thing,
        property,
        error,
        value,
        setDataset,
        setThing,
    };
}
function useDatetimeBrowserSupport() {
    const [isDatetimeSupported, setIsDatetimeSupported] = useState(null);
    useEffect(() => {
        const test = document.createElement("input");
        test.type = "datetime-local";
        setIsDatetimeSupported(test.type !== "text");
    }, []);
    return isDatetimeSupported;
}
async function updateDataset(datasetUrl, setDataset) {
    const latestDataset = await getSolidDataset(datasetUrl);
    setDataset(latestDataset);
}

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
function useFile(url) {
    const [error, setError] = useState();
    const [inProgress, setInProgress] = useState(false);
    const [data, setData] = useState();
    const { fetch } = useContext(SessionContext);
    useEffect(() => {
        if (!url)
            return;
        setInProgress(true);
        retrieveFile(url, fetch)
            .then((response) => {
            setData(response);
            setInProgress(false);
        })
            .catch((retrieveError) => {
            setError(retrieveError);
            setInProgress(false);
        });
    }, [url, fetch]);
    return { error, inProgress, data };
}

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * Fetches and displays an image, from a src found at a given property of a given [Thing](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-Thing). Can also be used to upload a new/replacement image file.
 */
function Image(_a) {
    var { thing: propThing, property: propProperty, properties: propProperties, edit, autosave, allowDelete, onSave, onError, maxSize, alt, inputProps, errorComponent: ErrorComponent, loadingComponent: LoadingComponent, deleteComponent: DeleteComponent, saveLocation, solidDataset } = _a, imgOptions = __rest(_a, ["thing", "property", "properties", "edit", "autosave", "allowDelete", "onSave", "onError", "maxSize", "alt", "inputProps", "errorComponent", "loadingComponent", "deleteComponent", "saveLocation", "solidDataset"]);
    const { fetch } = useContext(SessionContext);
    const values = useProperty({
        thing: propThing,
        property: propProperty,
        properties: propProperties,
        type: "url",
    });
    const { value, thing, error: thingError } = values;
    let valueError;
    if (!value) {
        valueError = new Error("No value found for property.");
    }
    const isFetchingThing = !thing && !thingError;
    const [error, setError] = useState(thingError !== null && thingError !== void 0 ? thingError : valueError);
    useEffect(() => {
        if (error) {
            if (onError) {
                onError(error);
            }
        }
    }, [error, onError, ErrorComponent]);
    const [imgObjectUrl, setImgObjectUrl] = useState();
    const { data, error: imgError, inProgress: fetchingFileInProgress, } = useFile(value);
    useEffect(() => {
        if (fetchingFileInProgress) {
            return;
        }
        if (imgError) {
            setError(imgError);
            return;
        }
        const imageObjectUrl = data && URL.createObjectURL(data);
        if (imageObjectUrl) {
            setImgObjectUrl(imageObjectUrl);
        }
    }, [data, fetchingFileInProgress, imgError]);
    const handleDelete = async () => {
        if (!propThing ||
            !solidDataset ||
            !propProperty ||
            typeof value !== "string" ||
            !autosave) {
            return;
        }
        try {
            const updatedThing = removeUrl(propThing, propProperty, value);
            const updatedDataset = setThing(solidDataset, updatedThing);
            const datasetSourceUrl = getSourceUrl(solidDataset);
            if (!datasetSourceUrl)
                return;
            await saveSolidDatasetAt(datasetSourceUrl, updatedDataset, {
                fetch,
            });
        }
        catch (e) {
            setError(e);
        }
    };
    const handleChange = async (input) => {
        const fileList = input.files;
        if (autosave && fileList && fileList.length > 0) {
            if (value) {
                const newObjectUrl = await overwriteFile(value, fileList[0], input, fetch, maxSize, onSave, onError);
                if (newObjectUrl) {
                    setImgObjectUrl(newObjectUrl);
                }
            }
            else if (!value && saveLocation) {
                const savedFile = await saveFileInContainer(saveLocation, fileList[0], {
                    fetch,
                });
                const savedFileUrl = getSourceUrl(savedFile);
                if (savedFileUrl && propThing && propProperty && solidDataset) {
                    setImgObjectUrl(savedFileUrl);
                    try {
                        const updatedThing = addUrl(propThing, propProperty, savedFileUrl);
                        const updatedDataset = setThing(solidDataset, updatedThing);
                        const datasetSourceUrl = getSourceUrl(solidDataset);
                        if (!datasetSourceUrl)
                            return;
                        await saveSolidDatasetAt(datasetSourceUrl, updatedDataset, {
                            fetch,
                        });
                    }
                    catch (e) {
                        setError(e);
                    }
                }
            }
        }
    };
    let imageComponent = null;
    if (isFetchingThing || fetchingFileInProgress) {
        let loader = (LoadingComponent && (React.createElement(LoadingComponent, null))) || React.createElement("span", null, "fetching data in progress");
        if (LoadingComponent === null) {
            loader = null;
        }
        return loader;
    }
    if (error) {
        imageComponent = ErrorComponent ? (React.createElement(ErrorComponent, { error: error })) : (React.createElement("span", null, error.toString()));
    }
    else if (value) {
        /* eslint-disable-next-line react/jsx-props-no-spreading */
        imageComponent = React.createElement("img", Object.assign({ src: imgObjectUrl, alt: alt !== null && alt !== void 0 ? alt : "" }, imgOptions));
    }
    return (React.createElement(React.Fragment, null,
        imageComponent,
        edit && (React.createElement("input", Object.assign({}, inputProps, { type: "file", accept: "image/*", onChange: (e) => handleChange(e.target) }))),
        allowDelete &&
            (DeleteComponent ? (React.createElement(DeleteComponent, { onClick: handleDelete })) : (React.createElement("button", { type: "button", onClick: handleDelete }, "Delete")))));
}

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const DatetimeValue = (props) => {
    var _a;
    const { thing: propThing, solidDataset: propDataset, property: propProperty, properties: propProperties, saveDatasetTo, onSave, onError, edit, autosave, inputProps } = props, other = __rest(props, ["thing", "solidDataset", "property", "properties", "saveDatasetTo", "onSave", "onError", "edit", "autosave", "inputProps"]);
    const { fetch } = useContext(SessionContext);
    const { value: thingValue, thing, property, dataset, setDataset, error, } = useProperty({
        dataset: propDataset,
        thing: propThing,
        type: "datetime",
        property: propProperty,
        properties: propProperties,
    });
    const isDatetimeSupported = useDatetimeBrowserSupport();
    useEffect(() => {
        if (error && onError) {
            onError(error);
        }
    }, [error, onError]);
    const formattedValue = thingValue
        ? thingValue
            .toISOString()
            .substring(0, thingValue.toISOString().length - 5)
        : null;
    const [value, setValue] = useState(formattedValue);
    let initialDateValue = "";
    if (!isDatetimeSupported) {
        initialDateValue = value === null || value === void 0 ? void 0 : value.split(/T(.+)/)[0].toString();
    }
    let initialTimeValue = "00:00";
    if (!isDatetimeSupported) {
        initialTimeValue = (_a = value === null || value === void 0 ? void 0 : value.split(/T(.+)/)[1]) === null || _a === void 0 ? void 0 : _a.toString();
    }
    const [time, setTime] = useState(initialTimeValue);
    const [date, setDate] = useState(initialDateValue);
    useEffect(() => {
        if ((!time && !date) || isDatetimeSupported)
            return;
        setValue(`${date !== null && date !== void 0 ? date : ""}T${time !== null && time !== void 0 ? time : "00:00"}`);
    }, [time, date, isDatetimeSupported]);
    /* Save Value value in the pod */
    const saveHandler = async (e) => {
        if (formattedValue !== value &&
            thing &&
            dataset &&
            e.target.reportValidity()) {
            const datetimeValue = value;
            const updatedResource = setDatetime(thing, property, new Date(`${datetimeValue}Z`));
            try {
                let savedDataset;
                if (saveDatasetTo) {
                    savedDataset = await saveSolidDatasetAt(saveDatasetTo, setThing(dataset, updatedResource), { fetch });
                    await updateDataset(saveDatasetTo, setDataset);
                }
                else if (hasResourceInfo(dataset)) {
                    savedDataset = await saveSolidDatasetAt(getSourceUrl(dataset), setThing(dataset, updatedResource), { fetch });
                    await updateDataset(getSourceUrl(dataset), setDataset);
                }
                else if (onError) {
                    onError(new Error("Please provide saveDatasetTo location for new data"));
                }
                if (!error && onSave) {
                    onSave(savedDataset, updatedResource);
                }
            }
            catch (saveError) {
                if (onError) {
                    onError(saveError);
                }
            }
        }
    };
    let inputType;
    if (isDatetimeSupported) {
        inputType = "datetime-local";
    }
    else {
        inputType = "datetime-workaround";
    }
    return (React.createElement(React.Fragment, null,
        // eslint-disable-next-line react/jsx-props-no-spreading
        !edit && dataset && thing && React.createElement("span", Object.assign({}, other), `${value}`),
        edit && dataset && thing && inputType === "datetime-local" && (React.createElement("input", Object.assign({ type: inputType, "aria-label": "Date and Time", step: "any" }, inputProps, { onChange: (e) => {
                setValue(e.target.value);
            }, onBlur: (e) => autosave && saveHandler(e), value: value, pattern: "[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}", placeholder: "yyyy-mm-ddThh:mm" }))),
        edit && dataset && thing && inputType === "datetime-workaround" && (React.createElement(React.Fragment, null,
            React.createElement("input", Object.assign({ type: "date", "aria-label": "Date", step: "any" }, inputProps, { onChange: (e) => {
                    setDate(e.target.value);
                }, onBlur: (e) => autosave && saveHandler(e), value: date, pattern: "[0-9]{4}-[0-9]{2}-[0-9]{2}", placeholder: "yyyy-mm-dd" })),
            React.createElement("input", { type: "time", "aria-label": "Time", value: time, onChange: (e) => setTime(e.target.value), onBlur: (e) => autosave && saveHandler(e), pattern: "[0-9]{2}:[0-9]{2}" })))));
};
DatetimeValue.defaultProps = {
    autosave: false,
    edit: false,
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const StringValue = (props) => {
    var _a;
    const { thing: propThing, solidDataset: propDataset, property: propProperty, properties: propProperties, saveDatasetTo, locale, onSave, onError, edit, autosave, inputProps } = props, other = __rest(props, ["thing", "solidDataset", "property", "properties", "saveDatasetTo", "locale", "onSave", "onError", "edit", "autosave", "inputProps"]);
    const { fetch } = useContext(SessionContext);
    const { value: thingValue, thing, property, dataset, setDataset, error, } = useProperty({
        dataset: propDataset,
        thing: propThing,
        type: "string",
        property: propProperty,
        properties: propProperties,
        locale,
    });
    useEffect(() => {
        if (error && onError) {
            onError(error);
        }
    }, [error, onError]);
    const formattedValue = (_a = thingValue === null || thingValue === void 0 ? void 0 : thingValue.toString()) !== null && _a !== void 0 ? _a : "";
    const [value, setValue] = useState(formattedValue);
    /* Save Value value in the pod */
    const saveHandler = async (e) => {
        if (formattedValue !== value &&
            thing &&
            dataset &&
            e.target.reportValidity()) {
            let updatedResource;
            if (locale) {
                updatedResource = setStringWithLocale(thing, property, value, locale);
            }
            else {
                updatedResource = setStringNoLocale(thing, property, value);
            }
            try {
                let savedDataset;
                if (saveDatasetTo) {
                    savedDataset = await saveSolidDatasetAt(saveDatasetTo, setThing(dataset, updatedResource), { fetch });
                    await updateDataset(saveDatasetTo, setDataset);
                }
                else if (hasResourceInfo(dataset)) {
                    savedDataset = await saveSolidDatasetAt(getSourceUrl(dataset), setThing(dataset, updatedResource), { fetch });
                    await updateDataset(getSourceUrl(dataset), setDataset);
                }
                else if (onError) {
                    onError(new Error("Please provide saveDatasetTo location for new data"));
                }
                if (!error && onSave) {
                    onSave(savedDataset, updatedResource);
                }
            }
            catch (saveError) {
                if (onError) {
                    onError(saveError);
                }
            }
        }
    };
    return (React.createElement(React.Fragment, null,
        // eslint-disable-next-line react/jsx-props-no-spreading
        !edit && dataset && thing && React.createElement("span", Object.assign({}, other), value),
        edit && dataset && thing && (React.createElement("input", Object.assign({ type: "text" }, inputProps, { onChange: (e) => {
                setValue(e.target.value);
            }, onBlur: (e) => autosave && saveHandler(e), value: value })))));
};
StringValue.defaultProps = {
    autosave: false,
    edit: false,
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const BooleanValue = (props) => {
    var _a;
    const { thing: propThing, solidDataset: propDataset, property: propProperty, properties: propProperties, saveDatasetTo, onSave, onError, edit, autosave, inputProps } = props, other = __rest(props, ["thing", "solidDataset", "property", "properties", "saveDatasetTo", "onSave", "onError", "edit", "autosave", "inputProps"]);
    const { fetch } = useContext(SessionContext);
    const { value: thingValue, thing, property, dataset, setDataset, error, } = useProperty({
        dataset: propDataset,
        thing: propThing,
        type: "boolean",
        property: propProperty,
        properties: propProperties,
    });
    useEffect(() => {
        if (error && onError) {
            onError(error);
        }
    }, [error, onError]);
    let formattedValue = thingValue;
    let initialBooleanValue = false;
    initialBooleanValue = (_a = thingValue) !== null && _a !== void 0 ? _a : false;
    formattedValue = initialBooleanValue.toString();
    const [value, setValue] = useState(formattedValue);
    const [booleanValue, setBooleanValue] = useState(initialBooleanValue);
    useEffect(() => {
        setValue(booleanValue.toString());
    }, [booleanValue]);
    /* Save Value value in the pod */
    const saveHandler = async (e) => {
        if (formattedValue !== value &&
            thing &&
            dataset &&
            e.target.reportValidity()) {
            const updatedResource = setBoolean(thing, property, booleanValue);
            try {
                let savedDataset;
                if (saveDatasetTo) {
                    savedDataset = await saveSolidDatasetAt(saveDatasetTo, setThing(dataset, updatedResource), { fetch });
                    await updateDataset(saveDatasetTo, setDataset);
                }
                else if (hasResourceInfo(dataset)) {
                    savedDataset = await saveSolidDatasetAt(getSourceUrl(dataset), setThing(dataset, updatedResource), { fetch });
                    await updateDataset(getSourceUrl(dataset), setDataset);
                }
                else if (onError) {
                    onError(new Error("Please provide saveDatasetTo location for new data"));
                }
                if (!error && onSave) {
                    onSave(savedDataset, updatedResource);
                }
            }
            catch (saveError) {
                if (onError) {
                    onError(saveError);
                }
            }
        }
    };
    return (React.createElement(React.Fragment, null,
        // eslint-disable-next-line react/jsx-props-no-spreading
        !edit && dataset && thing && React.createElement("span", Object.assign({}, other), `${value}`),
        edit && dataset && thing && (React.createElement("input", Object.assign({ type: "checkbox", checked: booleanValue }, inputProps, { onChange: (e) => {
                setBooleanValue(e.target.checked);
            }, onBlur: (e) => autosave && saveHandler(e), value: value })))));
};
BooleanValue.defaultProps = {
    autosave: false,
    edit: false,
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const UrlValue = (props) => {
    var _a;
    const { thing: propThing, solidDataset: propDataset, property: propProperty, properties: propProperties, saveDatasetTo, onSave, onError, edit, autosave, inputProps } = props, other = __rest(props, ["thing", "solidDataset", "property", "properties", "saveDatasetTo", "onSave", "onError", "edit", "autosave", "inputProps"]);
    const { fetch } = useContext(SessionContext);
    const { value: thingValue, thing, property, dataset, setDataset, error, } = useProperty({
        dataset: propDataset,
        thing: propThing,
        type: "url",
        property: propProperty,
        properties: propProperties,
    });
    useEffect(() => {
        if (error && onError) {
            onError(error);
        }
    }, [error, onError]);
    const formattedValue = (_a = thingValue === null || thingValue === void 0 ? void 0 : thingValue.toString()) !== null && _a !== void 0 ? _a : "";
    const [value, setValue] = useState(formattedValue);
    /* Save Value value in the pod */
    const saveHandler = async (e) => {
        if (formattedValue !== value &&
            thing &&
            dataset &&
            e.target.reportValidity()) {
            const updatedResource = setUrl(thing, property, value);
            try {
                let savedDataset;
                if (saveDatasetTo) {
                    savedDataset = await saveSolidDatasetAt(saveDatasetTo, setThing(dataset, updatedResource), { fetch });
                    await updateDataset(saveDatasetTo, setDataset);
                }
                else if (hasResourceInfo(dataset)) {
                    savedDataset = await saveSolidDatasetAt(getSourceUrl(dataset), setThing(dataset, updatedResource), { fetch });
                    await updateDataset(getSourceUrl(dataset), setDataset);
                }
                else if (onError) {
                    onError(new Error("Please provide saveDatasetTo location for new data"));
                }
                if (!error && onSave) {
                    onSave(savedDataset, updatedResource);
                }
            }
            catch (saveError) {
                if (onError) {
                    onError(saveError);
                }
            }
        }
    };
    return (React.createElement(React.Fragment, null,
        // eslint-disable-next-line react/jsx-props-no-spreading
        !edit && dataset && thing && React.createElement("span", Object.assign({}, other), `${value}`),
        edit && dataset && thing && (React.createElement("input", Object.assign({ type: "url" }, inputProps, { onChange: (e) => {
                setValue(e.target.value);
            }, onBlur: (e) => autosave && saveHandler(e), value: value })))));
};
UrlValue.defaultProps = {
    autosave: false,
    edit: false,
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const IntegerValue = (props) => {
    var _a;
    const { thing: propThing, solidDataset: propDataset, property: propProperty, properties: propProperties, saveDatasetTo, onSave, onError, edit, autosave, inputProps } = props, other = __rest(props, ["thing", "solidDataset", "property", "properties", "saveDatasetTo", "onSave", "onError", "edit", "autosave", "inputProps"]);
    const { fetch } = useContext(SessionContext);
    const { value: thingValue, thing, property, dataset, setDataset, error, } = useProperty({
        dataset: propDataset,
        thing: propThing,
        type: "integer",
        property: propProperty,
        properties: propProperties,
    });
    useEffect(() => {
        if (error && onError) {
            onError(error);
        }
    }, [error, onError]);
    const formattedValue = (_a = thingValue === null || thingValue === void 0 ? void 0 : thingValue.toString()) !== null && _a !== void 0 ? _a : "";
    const [value, setValue] = useState(formattedValue);
    /* Save Value value in the pod */
    const saveHandler = async (e) => {
        if (formattedValue !== value &&
            thing &&
            dataset &&
            e.target.reportValidity()) {
            const updatedResource = setInteger(thing, property, parseInt(value, 10));
            try {
                let savedDataset;
                if (saveDatasetTo) {
                    savedDataset = await saveSolidDatasetAt(saveDatasetTo, setThing(dataset, updatedResource), { fetch });
                    await updateDataset(saveDatasetTo, setDataset);
                }
                else if (hasResourceInfo(dataset)) {
                    savedDataset = await saveSolidDatasetAt(getSourceUrl(dataset), setThing(dataset, updatedResource), { fetch });
                    await updateDataset(getSourceUrl(dataset), setDataset);
                }
                else if (onError) {
                    onError(new Error("Please provide saveDatasetTo location for new data"));
                }
                if (!error && onSave) {
                    onSave(savedDataset, updatedResource);
                }
            }
            catch (saveError) {
                if (onError) {
                    onError(saveError);
                }
            }
        }
    };
    return (React.createElement(React.Fragment, null,
        // eslint-disable-next-line react/jsx-props-no-spreading
        !edit && dataset && thing && React.createElement("span", Object.assign({}, other), `${value}`),
        edit && dataset && thing && (React.createElement("input", Object.assign({ type: "number", step: "any" }, inputProps, { onChange: (e) => {
                setValue(e.target.value);
            }, onBlur: (e) => autosave && saveHandler(e), value: value })))));
};
IntegerValue.defaultProps = {
    autosave: false,
    edit: false,
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const DecimalValue = (props) => {
    var _a;
    const { thing: propThing, solidDataset: propDataset, property: propProperty, properties: propProperties, saveDatasetTo, onSave, onError, edit, autosave, inputProps } = props, other = __rest(props, ["thing", "solidDataset", "property", "properties", "saveDatasetTo", "onSave", "onError", "edit", "autosave", "inputProps"]);
    const { fetch } = useContext(SessionContext);
    const { value: thingValue, thing, property, dataset, setDataset, error, } = useProperty({
        dataset: propDataset,
        thing: propThing,
        type: "decimal",
        property: propProperty,
        properties: propProperties,
    });
    useEffect(() => {
        if (error && onError) {
            onError(error);
        }
    }, [error, onError]);
    const formattedValue = (_a = thingValue === null || thingValue === void 0 ? void 0 : thingValue.toString()) !== null && _a !== void 0 ? _a : "";
    const [value, setValue] = useState(formattedValue);
    /* Save Value value in the pod */
    const saveHandler = async (e) => {
        if (formattedValue !== value &&
            thing &&
            dataset &&
            e.target.reportValidity()) {
            const updatedResource = setDecimal(thing, property, parseFloat(value));
            try {
                let savedDataset;
                if (saveDatasetTo) {
                    savedDataset = await saveSolidDatasetAt(saveDatasetTo, setThing(dataset, updatedResource), { fetch });
                    await updateDataset(saveDatasetTo, setDataset);
                }
                else if (hasResourceInfo(dataset)) {
                    savedDataset = await saveSolidDatasetAt(getSourceUrl(dataset), setThing(dataset, updatedResource), { fetch });
                    await updateDataset(getSourceUrl(dataset), setDataset);
                }
                else if (onError) {
                    onError(new Error("Please provide saveDatasetTo location for new data"));
                }
                if (!error && onSave) {
                    onSave(savedDataset, updatedResource);
                }
            }
            catch (saveError) {
                if (onError) {
                    onError(saveError);
                }
            }
        }
    };
    return (React.createElement(React.Fragment, null,
        // eslint-disable-next-line react/jsx-props-no-spreading
        !edit && dataset && thing && React.createElement("span", Object.assign({}, other), `${value}`),
        edit && dataset && thing && (React.createElement("input", Object.assign({ type: "number", step: "any" }, inputProps, { onChange: (e) => {
                setValue(e.target.value);
            }, onBlur: (e) => autosave && saveHandler(e), value: value })))));
};
DecimalValue.defaultProps = {
    autosave: false,
    edit: false,
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * Retrieves and displays a value of one of a range of types from a given [Dataset](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-SolidDataset)/[Thing](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-Thing)/property. Can also be used to set/update and persist a value.
 */
function Value(props) {
    const _a = props, { dataType } = _a, otherProps = __rest(_a, ["dataType"]);
    const { thing: propThing, solidDataset: propDataset, property: propProperty, properties: propProperties, edit, loadingComponent: LoadingComponent, errorComponent: ErrorComponent, locale, } = otherProps;
    const { thing, value, error: thingError, } = useProperty({
        dataset: propDataset,
        thing: propThing,
        property: propProperty,
        properties: propProperties,
        type: dataType,
        locale,
    });
    let valueError;
    if (!edit && !value && dataType !== "boolean") {
        valueError = new Error("No value found for property.");
    }
    const isFetchingThing = !thing && !thingError;
    const [error] = useState(thingError !== null && thingError !== void 0 ? thingError : valueError);
    if (isFetchingThing) {
        let loader = (LoadingComponent && (React.createElement(LoadingComponent, null))) || React.createElement("span", null, "fetching data in progress");
        if (LoadingComponent === null) {
            loader = null;
        }
        return loader;
    }
    if (error) {
        if (ErrorComponent) {
            return React.createElement(ErrorComponent, { error: error });
        }
        return React.createElement("span", null, error.toString());
    }
    let Component = StringValue;
    switch (dataType) {
        case "boolean":
            Component = BooleanValue;
            break;
        case "datetime":
            Component = DatetimeValue;
            break;
        case "decimal":
            Component = DecimalValue;
            break;
        case "integer":
            Component = IntegerValue;
            break;
        case "url":
            Component = UrlValue;
            break;
        default:
            Component = StringValue;
    }
    // eslint-disable-next-line react/jsx-props-no-spreading
    return React.createElement(Component, Object.assign({}, otherProps));
}
Value.defaultProps = {
    autosave: false,
    edit: false,
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * Retrieves a URL from given [Thing](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-Thing)/property, and renders as an anchor tag with the given href.
 */
function Link(_a) {
    var { children, property: propProperty, properties: propProperties, thing: propThing, solidDataset, autosave, rel, target, edit, loadingComponent: LoadingComponent, errorComponent: ErrorComponent, onSave, onError } = _a, linkOptions = __rest(_a, ["children", "property", "properties", "thing", "solidDataset", "autosave", "rel", "target", "edit", "loadingComponent", "errorComponent", "onSave", "onError"]);
    const { value: href, thing, property, dataset, error: thingError, } = useProperty({
        dataset: solidDataset,
        thing: propThing,
        property: propProperty,
        properties: propProperties,
        type: "url",
    });
    let valueError;
    if (!edit && !href) {
        valueError = new Error("URL not found for given property");
    }
    const isFetchingThing = !thing && !thingError;
    const [error] = useState(thingError !== null && thingError !== void 0 ? thingError : valueError);
    if (isFetchingThing) {
        let loader = (LoadingComponent && (React.createElement(LoadingComponent, null))) || React.createElement("span", null, "fetching data in progress");
        if (LoadingComponent === null) {
            loader = null;
        }
        return loader;
    }
    if (error) {
        if (ErrorComponent) {
            return React.createElement(ErrorComponent, { error: error });
        }
        return React.createElement("span", null, error.toString());
    }
    const adjustedRel = rel || (target === "_blank" ? "noopener noreferrer" : "nofollow");
    if (edit) {
        return (React.createElement(Value, { dataType: "url", solidDataset: dataset, thing: thing, property: property, autosave: autosave, onSave: onSave, onError: onError, edit: true }));
    }
    return (
    // eslint-disable-next-line react/jsx-props-no-spreading
    React.createElement("a", Object.assign({ href: href, rel: adjustedRel, target: target }, linkOptions), children !== null && children !== void 0 ? children : href));
}

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * Displays a button which triggers the login flow on click. Should be used inside a `SessionProvider`.
 */
const LoginButton = ({ oidcIssuer, redirectUrl, children, authOptions, onError, }) => {
    const options = Object.assign({ redirectUrl,
        oidcIssuer }, authOptions);
    const { login, setSessionRequestInProgress } = useContext(SessionContext);
    async function loginHandler() {
        setSessionRequestInProgress(true);
        try {
            // Workaround for a solid-client-authn bug.
            // Typescript is mad about something.
            await login(options);
            setSessionRequestInProgress(false);
        }
        catch (error) {
            setSessionRequestInProgress(false);
            if (onError)
                onError(error);
        }
    }
    function keyDownHandler(e) {
        e.preventDefault();
        return e.key === "Enter" ? loginHandler() : Promise.resolve();
    }
    return children ? (React.createElement("div", { role: "button", tabIndex: 0, onClick: loginHandler, onKeyDown: keyDownHandler }, children)) : (React.createElement("button", { type: "button", onClick: loginHandler, onKeyDown: keyDownHandler }, "Log In"));
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * Renders a button which triggers logout on click. Should be used within a `SessionProvider`.
 */
const LogoutButton = ({ children, onLogout, onError, }) => {
    const { logout } = useContext(SessionContext);
    async function logoutHandler() {
        try {
            await logout();
            if (onLogout)
                onLogout();
        }
        catch (error) {
            if (onError)
                onError(error);
        }
    }
    function keyDownHandler(e) {
        e.preventDefault();
        return e.key === "Enter" ? logoutHandler() : Promise.resolve();
    }
    return children ? (React.createElement("div", { role: "button", tabIndex: 0, onClick: logoutHandler, onKeyDown: keyDownHandler }, children)) : (React.createElement("button", { type: "button", onClick: logoutHandler, onKeyDown: keyDownHandler }, "Log Out"));
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * Used to provide both a [Dataset](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-SolidDataset) and [Thing](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-Thing) to child components through context, as used by various provided components and the useDataset and useThing hooks.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function CombinedDataProvider(props) {
    const { children, solidDataset, datasetUrl, thing, thingUrl, onError, loadingComponent, } = props;
    return (React.createElement(DatasetProvider, { onError: onError, solidDataset: solidDataset, datasetUrl: datasetUrl, loadingComponent: loadingComponent },
        React.createElement(ThingProvider, { thing: thing, thingUrl: thingUrl }, children)));
}

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * To be used as the only children of a Table component. Each column represents one property of the Things passed to the Table.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function TableColumn(props) {
    throw new Error("Can't use TableColumn outside a Table.");
}
/**
 * Displays values from an array of [Things](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-Thing) as table rows, with each column showing a given property of those [Things](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-Thing).
 */
function Table(_a) {
    var { children, emptyStateComponent: EmptyStateComponent, things, filter, ascIndicator, descIndicator, getRowProps } = _a, tableProps = __rest(_a, ["children", "emptyStateComponent", "things", "filter", "ascIndicator", "descIndicator", "getRowProps"]);
    const { columns, data } = useMemo(() => {
        const columnsArray = [];
        const dataArray = things.map(() => ({}));
        // loop through each column
        Children.forEach(children, (column, colIndex) => {
            if (column) {
                const { property, header, body, dataType = "string", locale, multiple = false, sortable, sortFn, filterable, } = column.props;
                // add heading
                columnsArray.push({
                    Header: header !== null && header !== void 0 ? header : `${property}`,
                    accessor: `col${colIndex}`,
                    disableGlobalFilter: !filterable,
                    disableSortBy: !sortable,
                    Cell: body !== null && body !== void 0 ? body : (({ value }) => (value != null ? `${value}` : "")),
                });
                if (sortFn) {
                    const sortFunction = (a, b, columnId) => {
                        const valueA = a.values[columnId];
                        const valueB = b.values[columnId];
                        return sortFn(valueA, valueB);
                    };
                    columnsArray[colIndex].sortType = sortFunction;
                }
                else {
                    if (dataType === "string") {
                        columnsArray[colIndex].sortType = dataType;
                    }
                    if (dataType === "integer" || dataType === "decimal") {
                        columnsArray[colIndex].sortType = "number";
                    }
                }
                // add each each value to data
                things.forEach((thing, i) => {
                    dataArray[i][`col${colIndex}`] = multiple
                        ? getValueByTypeAll(dataType, thing.thing, property, locale)
                        : getValueByType(dataType, thing.thing, property, locale);
                });
            }
        });
        return { columns: columnsArray, data: dataArray };
    }, [children, things]);
    const tableInstance = useTable({
        columns,
        data,
        initialState: { globalFilter: filter || undefined },
    }, useGlobalFilter, useSortBy);
    const { getTableProps, getTableBodyProps, headerGroups, rows, prepareRow } = tableInstance;
    if (!rows.length) {
        if (EmptyStateComponent) {
            return React.createElement(EmptyStateComponent, null);
        }
        return null;
    }
    return (React.createElement("table", Object.assign({}, getTableProps(), tableProps),
        React.createElement("thead", null, headerGroups.map((headerGroup) => (React.createElement("tr", Object.assign({}, headerGroup.getHeaderGroupProps()), headerGroup.headers.map((column) => (React.createElement("th", Object.assign({}, column.getHeaderProps(column.getSortByToggleProps())),
            column.render("Header"),
            column.isSorted &&
                (column.isSortedDesc ? descIndicator : ascIndicator)))))))),
        React.createElement("tbody", Object.assign({}, getTableBodyProps()), rows.map((row) => {
            prepareRow(row);
            const rowDataset = things[row.index].dataset;
            const rowThing = things[row.index].thing;
            return (React.createElement("tr", Object.assign({}, row.getRowProps(getRowProps(row, rowThing, rowDataset))),
                React.createElement(CombinedDataProvider, { solidDataset: rowDataset, thing: rowThing }, row.cells.map((cell) => {
                    return (React.createElement("td", Object.assign({}, cell.getCellProps()), cell.render("Cell")));
                }))));
        }))));
}
Table.defaultProps = {
    filter: undefined,
    ascIndicator: (React.createElement("span", { role: "img", "aria-label": "Sorted in ascending order" },
        " ",
        "\uD83D\uDD3C")),
    descIndicator: (React.createElement("span", { role: "img", "aria-label": "Sorted in descending order" },
        " ",
        "\uD83D\uDD3D")),
    getRowProps: () => ({}),
};

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * Retrieves and displays a string from a given [Dataset](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-SolidDataset)/[Thing](https://docs.inrupt.com/developer-tools/javascript/client-libraries/reference/glossary/#term-Thing)/property. Can also be used to set/update and persist a string value.
 */
function Text(_a) {
    var { thing: propThing, solidDataset: propDataset, property: propProperty, properties: propProperties, saveDatasetTo, locale, onSave, onError, inputProps, errorComponent: ErrorComponent, loadingComponent: LoadingComponent, edit = false, autosave = false } = _a, other = __rest(_a, ["thing", "solidDataset", "property", "properties", "saveDatasetTo", "locale", "onSave", "onError", "inputProps", "errorComponent", "loadingComponent", "edit", "autosave"]);
    const { fetch } = useContext(SessionContext);
    const { error: thingError, value, thing, property, dataset, setDataset, } = useProperty({
        dataset: propDataset,
        thing: propThing,
        property: propProperty,
        properties: propProperties,
        type: "string",
        locale,
    });
    let valueError;
    if (!edit && !value) {
        valueError = new Error("No value found for property.");
    }
    const isFetchingThing = !thing && !thingError;
    const [error] = useState(thingError !== null && thingError !== void 0 ? thingError : valueError);
    useEffect(() => {
        if (error && onError) {
            onError(error);
        }
    }, [error, onError]);
    const [text, setText] = useState(value);
    const [, setErrorState] = useState();
    const [initialValue, setInitialValue] = useState(value);
    /* Save text value in the pod */
    const saveHandler = async (e) => {
        if (initialValue !== e.target.value && thing && dataset) {
            const newValue = e.target.value;
            let updatedResource;
            if (locale) {
                updatedResource = setStringWithLocale(thing, property, newValue, locale);
            }
            else {
                updatedResource = setStringNoLocale(thing, property, newValue);
            }
            try {
                let savedDataset;
                if (saveDatasetTo) {
                    savedDataset = await saveSolidDatasetAt(saveDatasetTo, setThing(dataset, updatedResource), { fetch });
                    await updateDataset(saveDatasetTo, setDataset);
                }
                else if (hasResourceInfo(dataset)) {
                    savedDataset = await saveSolidDatasetAt(getSourceUrl(dataset), setThing(dataset, updatedResource), { fetch });
                    await updateDataset(getSourceUrl(dataset), setDataset);
                }
                else {
                    setErrorState(() => {
                        throw new Error("Please provide saveDatasetTo location for new data");
                    });
                }
                if (onSave) {
                    onSave(savedDataset, updatedResource);
                }
            }
            catch (saveError) {
                if (onError) {
                    onError(saveError);
                }
            }
        }
    };
    if (isFetchingThing) {
        let loader = (LoadingComponent && (React.createElement(LoadingComponent, null))) || React.createElement("span", null, "fetching data in progress");
        if (LoadingComponent === null) {
            loader = null;
        }
        return loader;
    }
    if (error) {
        if (ErrorComponent) {
            return React.createElement(ErrorComponent, { error: error });
        }
        return React.createElement("span", null, error.toString());
    }
    return (React.createElement(React.Fragment, null,
        // eslint-disable-next-line react/jsx-props-no-spreading
        !edit && dataset && thing && React.createElement("span", Object.assign({}, other), text),
        edit && dataset && thing && (React.createElement("input", Object.assign({ type: inputProps && inputProps.type ? inputProps.type : "text" }, inputProps, { onFocus: (e) => setInitialValue(e.target.value), onChange: (e) => setText(e.target.value), onBlur: (e) => autosave && saveHandler(e), value: text || "" })))));
}

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * Fetches and displays a video, from a src found at a given property of a given Thing. Can also be used to upload a new/replacement video file.
 */
function Video(_a) {
    var { property: propProperty, properties: propProperties, thing: propThing, edit, autosave, onSave, onError, maxSize, inputProps, errorComponent: ErrorComponent, loadingComponent: LoadingComponent } = _a, videoOptions = __rest(_a, ["property", "properties", "thing", "edit", "autosave", "onSave", "onError", "maxSize", "inputProps", "errorComponent", "loadingComponent"]);
    const { fetch } = useContext(SessionContext);
    const values = useProperty({
        thing: propThing,
        property: propProperty,
        properties: propProperties,
        type: "url",
    });
    const { value, thing, error: thingError } = values;
    let valueError;
    if (!edit && !value) {
        valueError = new Error("No value found for property.");
    }
    const isFetchingThing = !thing && !thingError;
    const [error, setError] = useState(thingError !== null && thingError !== void 0 ? thingError : valueError);
    useEffect(() => {
        if (error) {
            if (onError) {
                onError(error);
            }
        }
    }, [error, onError, ErrorComponent]);
    const [videoObjectUrl, setVideoObjectUrl] = useState("");
    const { data, error: videoError, inProgress: fetchingVideoInProgress, } = useFile(value);
    useEffect(() => {
        if (fetchingVideoInProgress) {
            return;
        }
        if (videoError) {
            setError(videoError);
            return;
        }
        const videoObjectURL = data && URL.createObjectURL(data);
        if (videoObjectURL) {
            setVideoObjectUrl(videoObjectURL);
        }
    }, [data, fetchingVideoInProgress, videoError]);
    const handleChange = async (input) => {
        const fileList = input.files;
        if (autosave && fileList && fileList.length > 0 && value) {
            const newObjectUrl = await overwriteFile(value, fileList[0], input, fetch, maxSize, onSave, onError);
            if (newObjectUrl) {
                setVideoObjectUrl(newObjectUrl);
            }
        }
    };
    let videoComponent = null;
    if (isFetchingThing || fetchingVideoInProgress) {
        let loader = (LoadingComponent && (React.createElement(LoadingComponent, null))) || React.createElement("span", null, "fetching data in progress");
        if (LoadingComponent === null) {
            loader = null;
        }
        return loader;
    }
    if (error) {
        videoComponent = ErrorComponent ? (React.createElement(ErrorComponent, { error: error })) : (React.createElement("span", null, error.toString()));
    }
    else if (value) {
        videoComponent = (
        /* eslint jsx-a11y/media-has-caption: 0, react/jsx-props-no-spreading: 0 */
        React.createElement("video", Object.assign({ src: videoObjectUrl || value, controls: true }, videoOptions)));
    }
    return (React.createElement(React.Fragment, null,
        videoComponent,
        edit && (React.createElement("input", Object.assign({}, inputProps, { type: "file", accept: "video/*", onChange: (e) => handleChange(e.target) })))));
}

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
function useSession() {
    const { session, sessionRequestInProgress, fetch, login, logout } = useContext(SessionContext);
    return {
        session,
        sessionRequestInProgress,
        fetch,
        login,
        logout,
    };
}

/**
 * Copyright 2020 Inrupt Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
function useThing(datasetIri, thingIri, 
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
options
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    const { dataset, error } = useDataset(datasetIri, options);
    const { thing: thingFromContext } = useContext(ThingContext);
    if (!thingIri) {
        return { thing: thingFromContext || undefined, error };
    }
    if (!dataset) {
        return { thing: null, error };
    }
    const thing = getThing(dataset, thingIri);
    return { thing, error };
}

export { CombinedDataProvider, DatasetContext, DatasetProvider, FileUpload, Image, Link, LoginButton, LogoutButton, SessionContext, SessionProvider, Table, TableColumn, Text, ThingContext, ThingProvider, Value, Video, useDataset, useFile, useSession, useThing };
//# sourceMappingURL=index.mjs.map
